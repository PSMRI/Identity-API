spring.main.banner-mode=off
spring.data.jpa.repositories.enabled=true
spring.jpa.hibernate.ddl-auto=none

# Naming strategies
spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# The SQL dialect makes Hibernate generate better SQL for the chosen database
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# ============================================================================
# OPTIMIZED HIKARICP SETTINGS FOR HIGH CONCURRENCY
# ============================================================================

# Connection Pool Size - CRITICAL for handling multiple concurrent requests
# Rule: (max-pool-size) = (number of CPUs * 2) + effectiveSpindles
# For 8 CPUs: 8*2 + 4 = 20-30 is optimal
spring.datasource.hikari.maximum-pool-size=40
spring.datasource.hikari.minimum-idle=20

# Connection Timeouts - REDUCED for faster failure detection
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.validation-timeout=3000

# Idle/Lifetime - Prevents stale connections
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.keepalive-time=60000

# Leak Detection - CRITICAL for debugging connection issues
spring.datasource.hikari.leak-detection-threshold=30000

# MySQL Connection Properties - Keeps connections alive
spring.datasource.hikari.data-source-properties.cachePrepStmts=true
spring.datasource.hikari.data-source-properties.prepStmtCacheSize=500
spring.datasource.hikari.data-source-properties.prepStmtCacheSqlLimit=4096
spring.datasource.hikari.data-source-properties.useServerPrepStmts=true
spring.datasource.hikari.data-source-properties.rewriteBatchedStatements=true
spring.datasource.hikari.data-source-properties.maintainTimeStats=false

# CRITICAL: Prevents MySQL "connection lost" errors
spring.datasource.hikari.data-source-properties.autoReconnect=true
spring.datasource.hikari.data-source-properties.tcpKeepAlive=true
spring.datasource.hikari.data-source-properties.socketTimeout=60000
spring.datasource.hikari.data-source-properties.connectTimeout=10000

# Health check
spring.datasource.hikari.health-check-properties.connectivityCheckTimeoutMs=3000

# ============================================================================
# HIBERNATE PERFORMANCE TUNING
# ============================================================================

# Batch processing for bulk operations
spring.jpa.properties.hibernate.jdbc.fetch_size=100
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# Query timeout (60 seconds)
spring.jpa.properties.hibernate.query.timeout=60000

# Statement cache
spring.jpa.properties.hibernate.query.plan_cache_max_size=2048
spring.jpa.properties.hibernate.query.plan_parameter_metadata_max_size=128

# ============================================================================
# REDIS SESSION MANAGEMENT
# ============================================================================
spring.session.store-type=redis
spring.redis.password=
spring.redis.port=6379

# Redis connection pool
spring.redis.lettuce.pool.max-active=20
spring.redis.lettuce.pool.max-idle=10
spring.redis.lettuce.pool.min-idle=5
spring.redis.lettuce.pool.max-wait=3000ms

# Session expiry
iemr.extend.expiry.time=true
iemr.session.expiry.time=7200
enableIPValidation=false

# ============================================================================
# ELASTICSEARCH CONFIGURATION - OPTIMIZED
# ============================================================================

# Connection timeouts - Balanced for reliability
elasticsearch.connection.timeout=5000
elasticsearch.socket.timeout=30000
elasticsearch.max.retry.timeout=60000

# Connection pooling - INCREASED for concurrent searches
elasticsearch.max.connections=100
elasticsearch.max.connections.per.route=50

# Request configuration
elasticsearch.request.timeout=10000
elasticsearch.max.result.window=10000

# Bulk indexing - OPTIMIZED for background sync
elasticsearch.bulk.size=1000
elasticsearch.bulk.concurrent.requests=4
elasticsearch.bulk.flush.interval=10s

# Search performance - FAST response for user queries
elasticsearch.search.default.size=100
elasticsearch.search.max.size=500
elasticsearch.search.timeout=5s

# Query cache - CRITICAL for repeated searches
elasticsearch.query.cache.enabled=true
elasticsearch.query.cache.size=15%

# Request cache - Speeds up identical queries
elasticsearch.request.cache.enabled=true

# Circuit breaker - Prevents OOM
elasticsearch.circuit.breaker.enabled=true
elasticsearch.circuit.breaker.limit=90%

# Async operations thread pool
elasticsearch.async.thread.pool.size=10
elasticsearch.async.thread.pool.queue.size=2000

elasticsearch.bulk.refresh.interval=5

# ============================================================================
# LOGGING - Balanced for debugging
# ============================================================================
logging.level.root=INFO
logging.level.org.springframework.web=INFO
logging.level.org.hibernate=INFO
logging.level.com.iemr=DEBUG
logging.level.org.springframework=INFO
logging.level.com.zaxxer.hikari=INFO
logging.level.com.zaxxer.hikari.pool.HikariPool=DEBUG

# Log slow queries (helps identify bottlenecks)
logging.level.org.hibernate.SQL=WARN
spring.jpa.properties.hibernate.show_sql=false

# ============================================================================
# APPLICATION SPECIFIC
# ============================================================================
door-to-door-page-size=2
get-HRP-Status=ANC/getHRPStatus
getHealthID=healthID/getBenhealthID

spring.main.allow-bean-definition-overriding=true
spring.main.allow-circular-references=true

jwt.access.expiration=86400000
jwt.refresh.expiration=604800000

